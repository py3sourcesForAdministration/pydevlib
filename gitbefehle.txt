#--- ein Directory auf dem Server erstellen für gruppenzugriff ohne worktree
#--- hier in /home/all/gitsrv auf centosap 
git init --bare --shared=group  pysrc.git
#--- für die Subprojecte wiederholen -- hier Versuch innerhalb des bereits bestehenden
cd pysrc.git
git init --bare --shared=group  rxe.git
.....

############################## Befüllen des Servers
#--- ein leeres directory erstellen mit dem Superproject
mkdir /home/all/gitsrv/gitinput/pysrc
cd !$
git init
#--- die initialen Datein in dieses Directory kopieren
git add */*
#--- besser, da nur die Dateien aufgenommen werden, die nicht durch .gitignore ausgeschlossen werden 
git add .
git status
git commit  -m 'initial new'
#--- directory inhalt zum Server pushen
git push ssh://centosap.psw.local/home/all/gitsrv/pysrc.git '*:*'

#--- auf dem Server für jedes subproject Befüllen wiederholen
mkdir /home/all/gitsrv/gitinput/rxe
.....
git push ssh://centosap.psw.local/home/all/gitsrv/pysrc.git/rxe.git '*:*'
...

#--- jetzt das server repository auf einem Client auschecken
#--- in das gewünscghte home verzeichnis auf dem client wechseln
git clone --recurse-submodules -j 2 ap@centosap:/home/all/gitsrv/pysrc.git
#---
#--- für alle subprojekte
git submodule add ssh://centosap.psw.local/home/all/gitsrv/pysrc.git/rxe.git
die submodule aber in .gitignore ausschliessen und .gitmodules ausschließen





für jedes Subrepository

cd pysrc.git
git submodule add --init --bare --shared=group ./Dsearch.git 


####################################################################
Befüllen eines remote repositories mit einem lokalen Verzeichnis
1. Erzeugen des remote repos als leeres repo auf dem Server
  mkdir /home/all/gitsrv/py3dev/
  cd /home/all/gitsrv/py3dev/
  git init --bare --shared=group mypylib.git

2. Auf der lokalen Maschine das Verzeichnis zum Repo machen
  git init
  git add .
  git status
  git commit

3. Das leere Server als origin setzen und pushen
  git remote add origin ssh://centosap/home/all/gitsrv/py3dev/mypylib.git
  git push ssh://centosap.psw.local/home/all/gitsrv/py3dev/testpy.git '*:*'

4. Das befüllte Server repo zum master branch machen
  git push --set-upstream origin master
  


#######################################################################################
# Die remote repositories anzeigen
git remote -v

#######################################################################################
# Zum Kopieren zu ITergo
cd pydev/patchwait
tar cvzf  /tmp/.x2go-ap@psw.local/media/disk/_cygdrive_C_Users_A285687_Home/2021-02-05_patchwait.tgz -X .gitignore .

#######################################################################################
Man kann auch ein normales (non bare) Verzeichnis auf Rechner A als remote für Rechner B setzen. 
Beispiel: Rechner A centosap:/home/ap/pydev/testpy/ mit lokalem .git, aber ohne remote
          Rechner B ul30:/home/ap/pydev/testpy, git remote ssh://centosap/home/ap/pydev/testpy/.git
Nachteil:
Von diesem Verzeichnis kann man zwar Clone, Fetch, Pull machen (B fragt A ),kann aber nur mit Schwierigkeiten einen
Push (B -> A) ausführen. Das Verzeichnis ist ja auf Rechner A ebenfalls ausgecheckt, weigert sich daher in 
diesem Zustand eine Änderung entgegenzunehmen.
Abhilfe:  
Rechner A: im Verzeichnis auf A ausführen (nur beim ersten Mal)
  git config receive.denycurrentbranch [ignore|warn]
Rechner B: der die Änderungen hat,
  git push oder in VSCode sync
Rechner A: git reset --hard     # Das überschreibt den Inhalt von .git
           git checkout         # Das bringt das Working Directory auf den Stand von .git

Besser ein bare Repository, in dem beide schreiben können.
Tip für VScode: gitautofetch einrichten, dann werden die Änderungen, die andere im remote gemacht haben 
auch unter source Control angezeigt. Leider nur mit dem Sync Zeichen, also vor dem Arbeiten erstmal nachsehen,
ob man auf dem aktuellen Stand des Repos ist.   

